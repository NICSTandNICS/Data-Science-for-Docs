---
title: "Tidying Data in R"
author: "The DSBC team"
output: ioslides_presentation
---

<!--
Notes

- check that ggplot2 and dplyr are installed with Rstudio
- use diamonds data from ggplot

A data frame with 53940 rows and 10 variables:
    - price: price in US dollars (\$326–\$18,823)
    - carat: weight of the diamond (0.2–5.01)
    - cut: quality of the cut (Fair, Good, Very Good, Premium, Ideal)
    - color: diamond colour, from J (worst) to D (best)
    - clarity: a measurement of how clear the diamond is (I1 (worst), SI1, SI2, VS1, VS2, VVS1, VVS2, IF (best))
    - x: length in mm (0–10.74)
    - y: width in mm (0–58.9)
    - z: depth in mm (0–31.8)
    - depth: total depth percentage = z / mean(x, y) = 2 * z / (x + y) (43–79)
    - table: width of top of diamond relative to widest point (43–95)

- teach the basic use of dplyr

 -->


```{r setup, eval=TRUE}
rm(list=ls(all=TRUE))
library(ggplot2)
library(dplyr)

data(diamonds)



```

```{r inspect, eval=TRUE}

# Nice pretty table of your data
tbl_df(diamonds)

# Open spreadsheet like view
View(diamonds)

```

Simple tasks you might wish to do

```{r simple, eval=TRUE}

# Sort your data 
tbl_df(diamonds)
diamonds %>% arrange(carat) %>% tbl_df()
diamonds %>% arrange(desc(carat)) %>% tbl_df()

# Rename a column
diamonds <- rename(diamonds, length=x)
diamonds <- rename(diamonds, width=y)
diamonds <- rename(diamonds, depth=z)
tbl_df(diamonds)

# Filter your data (subset observations)
# will need to teach <,>,==,<=,>=
filter(diamonds, carat>4)

# Subset columns
data(iris)
tbl_df(iris)
select(iris, ends_with("width"))
head(select(iris, ends_with("width")))

# Summarise data
summarise(diamonds, avg=mean(carat))
count(diamonds,cut)
summarise_each(diamonds, funs( min, max ))

diamonds %>% group_by(color) %>% summarise(avg = mean(price))

```


Things which are difficult to do in Excel but very useful

```{r tidyr, eval=TRUE}
library(tidyr)
```


## Aims

1. Merging Columns
     - Dates
     - Time
2. Splitting Columns
     - Systolic/Diastolic
  
## Merging columns

Examples

1. Date is given as 3 seeperate columns, Year, Month and Day.
2. Time is given as 2 seperate columsm, Hour and Minutes.

## Dates
Merging columns into a single data field is very easy to do in R. Optionally, I prefer to put that variable back into the imported data frame:

```{r, eval=FALSE}
df$date_full <- paste(df$day, df$month, df$year, sep="/")
```

This will create a new column in the data frame called `data_full`. It will contain the day, month and year separated by a /.

Notice that this is just a String of character as yet, there is no object/concept of a date yet. 

If you try and subtract 3 days from that column, the result is strange akin to trying to subtract 3 from "Ahmed".

## Dates
To convert the column to a formatted, conceptualised date, use:
```{r, eval=FALSE}
df$date_full <- as.Date(df$date_full, format="%d/%m/%Y)
```

It is now possible to manipulate the the `date_full` column as expected.

## Time

Time in R requires to be converted to a full DateTime object; there is no concept of time along without a date hence some extra steps are needed

```{r, eval=FALSE}
start_time_stamp <- with(df, ISOdatetime(date_year, date_month, date_day, start_hour, start_minute, "00"))
df$start_time <- strftime(df$start_time_stamp, format="%H:%M:%S")
```

## Time
The above statement is rather long but let's simplify it step by step:

1. We're creating a new variable called start_time_stamp.
2. We are using a new function called `with`. This allows us to avoid using data$date_year, data$date_month and just focus on the column names only.
3. `ISOdatetime`. This creates a `datetime` object using a year, month, day, hour, minute and seconds. We do not have seconds in our dataset so I've hardcoded 0 seconds.
4. `strftime` function allows us to re-format the `start_time_stamp` object to only hours, minutes and seconds while allowing us to manipulate time as one would expect.

## Splitting Data

Examples:

1. BP values are given as 120/80 in one column. This can be problematic as the / can be interpreted as a division, resulting in a meaningless value of "1.5" - not what we would expect.

Recommendations:
Split BP values into two columns, systolic and diastolic.

## Splitting Data
If your data already has BP data stored as one column, we can fix that by first installing a package that helps with column manipulations called `tidyr`

```{r, eval=FALSE}
install.packages("tidyr")
```

then:
```{r, eval=FALSE}
separate(data = df, 
         col = BP, 
         into = c("Systolic", "Diastolic"),
         sep = "\\/")
```
note the sep variable, it is a "regular expression" and as our data is using a / we need to escape it by using the escape character "\\\\"

## Questions?